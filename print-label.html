<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>Print Label</title>

    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: white;
        }

        #printRoot {
            width: 100%;
            height: 100%;
            background: white;
        }

        img {
            display: block;
        }
    </style>
</head>

<body>
<div id="printRoot"></div>

<script>
    const DPI = 96;

    function unitToInch(unit, value) {
        if (!unit) return value;
        unit = unit.toLowerCase();

        if (unit === "in") return value;
        if (unit === "cm") return value / 2.54;
        if (unit === "mm") return value / 25.4;
        if (unit === "px") return value / DPI;

        return value;
    }

    function loadImage(src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => resolve(img);
            img.onerror = () => resolve(null);
            img.src = src;
        });
    }

    function injectPrintStyle(inchWidth, inchHeight) {
        const old = document.getElementById("printStyle");
        if (old) old.remove();

        const style = document.createElement("style");
        style.id = "printStyle";

        style.innerHTML = `
      @media print {
        @page {
          size: ${inchWidth}in ${inchHeight}in;
          margin: 0;
        }

        html, body {
          margin: 0;
          padding: 0;
          overflow: hidden;
          background: white;
        }

        #printRoot {
          width: 100%;
          height: 100%;
        }

        img {
          width: calc(100% - 1px);
          height: calc(100% - 1px);
        }
      }
    `;

        document.head.appendChild(style);
    }

    async function renderMarkupToCanvas(markup) {
        const stage = markup.stage;

        const inchWidth = unitToInch(stage.unit, stage.width);
        const inchHeight = unitToInch(stage.unit, stage.height);

        // ðŸ”¥ Higher scale = better quality + lines visible
        const SCALE = 4;

        const canvasWidth = Math.floor(inchWidth * DPI * SCALE);
        const canvasHeight = Math.floor(inchHeight * DPI * SCALE);

        const canvas = document.createElement("canvas");
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        const ctx = canvas.getContext("2d");

        // Scale to match markup coordinates
        ctx.scale(SCALE, SCALE);

        // Background
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, inchWidth * DPI, inchHeight * DPI);

        const elements = markup.elements || [];

        for (const el of elements) {

            // ---------------- TEXT ----------------
            if (el.type === "text") {
                const fontSize = el.font?.size || 14;
                const fontFamily = el.font?.family || "Arial";
                const fontStyle = el.font?.style || "normal";
                const color = el.font?.color || "#000000";

                ctx.save();

                ctx.globalAlpha = el.opacity ?? 1;

                ctx.translate(el.x || 0, el.y || 0);

                const rotation = (el.rotation || 0) * Math.PI / 180;
                ctx.rotate(rotation);

                const scaleX = el.scaleX || 1;
                const scaleY = el.scaleY || 1;
                ctx.scale(scaleX, scaleY);

                ctx.fillStyle = color;
                ctx.font = `${fontStyle} ${fontSize}px ${fontFamily}`;
                ctx.textBaseline = "top";

                ctx.fillText(el.text || "", 0, 0);

                ctx.restore();
            }

            // ---------------- IMAGE / BARCODE ----------------
            if (el.type === "image" || el.type === "barcode") {
                const img = await loadImage(el.url);
                if (!img) continue;

                ctx.save();

                ctx.globalAlpha = el.opacity ?? 1;

                ctx.translate(el.x || 0, el.y || 0);

                const rotation = (el.rotation || 0) * Math.PI / 180;
                ctx.rotate(rotation);

                const scaleX = el.scaleX || 1;
                const scaleY = el.scaleY || 1;
                ctx.scale(scaleX, scaleY);

                const w = el.width || img.width;
                const h = el.height || img.height;

                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = "high";

                ctx.drawImage(img, 0, 0, w, h);

                ctx.restore();
            }

            if (el.type === "line") {
                ctx.save();

                ctx.globalAlpha = el.opacity ?? 1;

                ctx.translate(el.x || 0, el.y || 0);

                const rotation = (el.rotation || 0) * Math.PI / 180;
                ctx.rotate(rotation);

                const scaleX = el.scaleX || 1;
                const scaleY = el.scaleY || 1;
                ctx.scale(scaleX, scaleY);

                ctx.strokeStyle = el.stroke || "#000000";
                ctx.lineWidth = el.strokeWidth || 2;

                ctx.imageSmoothingEnabled = false;

                const points = el.points || [];

                if (points.length >= 4) {
                    ctx.beginPath();
                    ctx.moveTo(points[0], points[1]);

                    for (let i = 2; i < points.length; i += 2) {
                        ctx.lineTo(points[i], points[i + 1]);
                    }

                    ctx.stroke();
                }

                ctx.restore();
            }

            if (el.type === "rect") {
                ctx.save();

                ctx.globalAlpha = el.opacity ?? 1;

                const fill = el.fill || null;
                const stroke = el.stroke || null;
                const strokeWidth = el.strokeWidth || 1;

                ctx.translate(el.x || 0, el.y || 0);

                const rotation = (el.rotation || 0) * Math.PI / 180;
                ctx.rotate(rotation);

                const scaleX = el.scaleX || 1;
                const scaleY = el.scaleY || 1;
                ctx.scale(scaleX, scaleY);

                if (fill) {
                    ctx.fillStyle = fill;
                    ctx.fillRect(0, 0, el.width || 0, el.height || 0);
                }

                if (stroke) {
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.strokeRect(0, 0, el.width || 0, el.height || 0);
                }

                ctx.restore();
            }
        }

        return {
            canvas,
            inchWidth,
            inchHeight
        };
    }

    async function printMarkup(markup) {
        const root = document.getElementById("printRoot");
        root.innerHTML = "";

        const {canvas, inchWidth, inchHeight} = await renderMarkupToCanvas(markup);

        const img = new Image();
        img.src = canvas.toDataURL("image/png");

        img.style.width = "calc(100% - 1px)";
        img.style.height = "calc(100% - 1px)";

        root.appendChild(img);

        injectPrintStyle(inchWidth, inchHeight);

        setTimeout(() => {
            window.print();
        }, 200);
    }

    // called from test_label.html iframe
    window.renderAndPrint = async function (markup) {
        console.log("Received markup:", markup);
        await printMarkup(markup);
    };
</script>
</body>
</html>
